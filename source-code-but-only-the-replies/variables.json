{
    "modalValue": "(args.modalValue == undefined || args.modalValue == null || args.modalValue == 'undefined') ? '' : args.modalValue",
    "old_roles": "(args.oldRoles == '' || args.oldRoles == ' ') ? 'No roles' : args.oldRoles",
    "new_roles": "(args.newRoles == '' || args.newRoles == ' ') ? 'No roles' : args.newRoles",
    "no_args": "",
    "server_name": "args.serverName",
    "reporter": "args.reporter",
    "server_invite": "args.serverInvite == 'undefined' || args.serverInvite == ''  ? 'No invite provided' : args.serverInvite",
    "images": "args.images == 'undefined' || args.images == '' || args.images == undefined  ? 'No images provided' : args.images",
    "server_id": "args.serverId",
    "boolean_emoji": "args.boolean ? client.replyEmojis['success'] : client.replyEmojis['wrong']",
    "count": "args.count",
    "count2": "args.count2",
    "placeholder": "args.placeholder",
    "interaction_user_tag": "interaction.user?.tag",
    "interaction_user_id": "interaction.user?.id",
    "emoji_bot": "checkEmoji(args.canUseEmoji, client.replyEmojis['bot'])",
    "emoji_tools": "checkEmoji(args.canUseEmoji, client.replyEmojis['tools'])",
    "emoji_support": "checkEmoji(args.canUseEmoji, client.replyEmojis['support'])",
    "emoji_crown": "checkEmoji(args.canUseEmoji, client.replyEmojis['crown'])",
    "emoji_translate": "checkEmoji(args.canUseEmoji, client.replyEmojis['translate'])",
    "autolock_roles": "args.autoLockRoles",
    "text": "args.text",
    "current_emoji_url": "args.currentEmoji?.url || args.currentEmoji?.image",
    "interaction_options_channel": "interaction.options?.get('channel')?.value",
    "interaction_options_comment": "interaction.options.get('extra_infos') ? interaction.options.get('extra_infos').value : 'No comment'",
    "interaction_options_creator": "interaction.options.get('creator') ? interaction.options.get('creator').value : 'No creator added'",
    "interaction_options_role": "interaction.options.get('role')?.value",
    "interaction_channel": "interaction.options?.get('channel')?.value || interaction.channel?.id",
    "interaction_options_description": "interaction.options.get('description')?.value",
    "interaction_options_name": "interaction.options.get('name')?.value",
    "interaction_options_emoji": "interaction.options.get('emoji')?.value",
    "interaction_options_language": "interaction.options.get('language')?.value",
    "sticker_name": "args.sticker?.name",
    "attachment_url": "args.attachment?.url",
    "permissions": "args.permissions",
    "blacklist_emojis": "args.blacklistEmojis",
    "emojis": "args.emojis",
    "role": "args.role",
    "emoji": "args.currentEmoji.image ? `<${args.currentEmoji.animated === true ? 'a' : ''}:${args.currentEmoji.name}:${args.currentEmoji.id}>` :  args.currentEmoji.toString()",
    "lock_roles": "args.lockRoles?.map(role => `<@&${role}>`).join(', ')",
    "user_tag_or_mention": "args.user?.tag || `<@${args.user?.id}>`",
    "blacklisted_emoji_comment": "args.blacklistedEmoji?.comment",
    "current_emoji_roles": " let roles = (args.rolesCurrentEmoji == 'Nothing'  ?  await client.getLanguage.getCommandContent('emoji-info', ['interactions', 'slash_commands'], interaction, { 'type': 'nothing', 'interaction': interaction}) : args.rolesCurrentEmoji?.join(', ')); return roles",
    "current_emoji_id": "args.currentEmoji?.id",
    "current_emoji_name": "args.currentEmoji.name",
    "current_emoji_author": "let author = await args.currentEmoji.fetchAuthor(); return author.username + '#' + author.discriminator",
    "current_emoji_creation_timestamp": "Math.floor(args.currentEmoji.createdTimestamp / 1000)",
    "current_emoji_managed": "return args.currentEmoji.managed == true ? await client.getLanguage.getCommandContent('emoji-info', ['interactions', 'slash_commands'], interaction, { 'type': 'true', 'interaction': interaction}) : await client.getLanguage.getCommandContent('emoji-info', ['interactions', 'slash_commands'], interaction, { 'type': 'false', 'interaction': interaction})",
    "new_emoji_name": "args.newEmoji.name",
    "new_emoji_name_interaction": "args.interaction.options?.get('name').value",
    "new_language_interaction": "args.interaction.options?.get('language')?.value",
    "new_language": "client.supportedLanguages.get(args.interaction.options?.get('language')?.value)?.native_name",
    "new_language_button": "client.supportedLanguages.get(args.newLanguage)?.native_name",
    "error": "args.error",
    "user_tag": "args.user?.tag || args.interaction.user?.tag",
    "user_id": "args.user?.id || args.interaction.user?.id",
    "interaction_guild_name_blacklist": "interaction.guild.name.length > 60 ? interaction.guild.name.slice(0, -40) : interaction.guild.name",
    "blacklisted_emojis": "args.blacklistedEmojis",
    "interaction_guild_icon": "interaction.guild.iconURL({ dynamic: true }) !== null ? interaction.guild.iconURL({ dynamic: true }) : 'https://cdn.discordapp.com/embed/avatars/0.png'",
    "guild_name": "args.interaction?.guild?.name",
    "attachment_name": "args.attachment?.name",
    "timestamp": "new Date()",
    "reason": "args.reason === null || args.reason == 'null' ? 'No reason' : args.reason",
    "reason_option": "let regex_match = content.match(/\\[\\{reason_option\\}(?<reason>.{0,30})\\]/s); (args.reason == undefined || args.reason == null || args.reason == '') ?  content = content.replace(/\\[\\{reason_option\\}.{0,30}\\]/s, '') : content = content.replace(/\\[\\{reason_option\\}.{0,30}\\]/s, regex_match.groups.reason)",
    "lock_emoji_roles": "let regex_match = content.match(/\\[\\{lock_emoji_roles\\}(?<text>.{0,999})\\]/); args.oldRoles !== args.newRoles ? content = content.replace(/\\[\\{lock_emoji_roles\\}.{0,999}\\]/, regex_match.groups.text) : content = content.replace(/\\[\\{lock_emoji_roles\\}.{0,999}\\]/, '')",
    "old_name_option": "let regex_match = content.match(/\\[\\{old_name_option\\}(?<text>.{0,30})\\]/); (args.currentEmoji !== undefined || args.currentEmoji !== null || args.currentEmoji !== '') && args.currentEmoji?.name !== args.newEmoji?.name ?  content = content.replace(/\\[\\{old_name_option\\}.{0,30}\\]/, regex_match.groups.text) : content = content.replace(/\\[\\{old_name_option\\}.{0,30}\\]/, '')",
    "new_name_option": "let regex_match = content.match(/\\[\\{new_name_option\\}(?<text>.{0,100})\\]/); (args.currentEmoji !== undefined || args.currentEmoji !== null || args.currentEmoji !== '') && args.currentEmoji?.name !== args.newEmoji?.name ? content = content.replace(/\\[\\{new_name_option\\}.{0,100}\\]/, regex_match.groups.text) : content = content.replace(/\\[\\{new_name_option\\}.{0,100}\\]/, '')",
    "current_sticker_id": "args.currentSticker?.id",
    "current_sticker_format": "args.currentSticker?.format",
    "current_sticker_name": "args.currentSticker.name",
    "current_sticker_author": "let author = await args.currentSticker?.fetchUser(); return `<@${author.id}>`",
    "current_sticker_tags": "!args.currentSticker?.tags.join(' ').match(emojiRegex()) ? content = content.replace('{current_sticker_tags}', `:${args.currentSticker?.tags.join(' ')}:`) : content = content.replace('{current_sticker_tags}', args.currentSticker?.tags.join(' '))",
    "current_sticker_available": "return args.currentSticker?.available == true ? await client.getLanguage.getCommandContent('sticker-information', ['interactions', 'slash_commands'], interaction, { 'type': 'true', 'interaction': interaction}) : await client.getLanguage.getCommandContent('sticker-information', ['interactions', 'slash_commands'], interaction, { 'type': 'false', 'interaction': interaction})",
    "current_sticker_description_info": "return args.currentSticker?.description !== '' ? args.currentSticker.description : await client.getLanguage.getCommandContent('sticker-information', ['interactions', 'slash_commands'], interaction, { 'type': 'no_description', 'interaction': interaction})",
    "new_sticker_tags": "!args.newSticker?.tags.join(' ').match(emojiRegex()) ? content = content.replace('{new_sticker_tags}', `:${args.newSticker?.tags.join(' ')}:`) : content = content.replace('{new_sticker_tags}', `args.newSticker?.tags.join(' '))",
    "new_sticker_name": "args.newSticker.name",
    "new_sticker_id": "args.newSticker.id",
    "sticker_new_description_option": "let regex_match = content.match(/\\[\\{sticker_new_description_option\\}(?<text>.{0,5000})\\]/s);  args.currentSticker.description !== args.newSticker.description ? content = content.replace(/\\[\\{sticker_new_description_option\\}.{0,5000}\\]/s, regex_match.groups.text) : content = content.replace(/\\[\\{sticker_new_description_option\\}.{0,5000}\\]/s, '')",
    "new_sticker_description": "(args.newSticker.description !== null && args.newSticker.description !== undefined && args.newSticker.description.length > 0) ? \nargs.newSticker.description : ''",
    "sticker_old_related_emoji_option": "let regex_match = content.match(/\\[\\{sticker_old_related_emoji_option\\}(?<text>.{0,100})\\]/s); args.currentSticker.tags.join('') !== args.newSticker.tags.join('') ? content = content.replace(/\\[\\{sticker_old_related_emoji_option\\}.{0,100}\\]/s, regex_match.groups.text) : content = content.replace(/\\[\\{sticker_old_related_emoji_option\\}.{0,100}\\]/s, '')",
    "sticker_old_name_option": "let regex_match = content.match(/\\[\\{sticker_old_name_option\\}(?<text>.{0,100})\\]/s);  args.currentSticker.name !== args.newSticker.name ? content = content.replace(/\\[\\{sticker_old_name_option\\}.{0,100}\\]/s, regex_match.groups.text) : content = content.replace(/\\[\\{sticker_old_name_option\\}.{0,100}\\]/s, '')",
    "current_sticker_description": "(args.currentSticker.description !== null && args.currentSticker.description !== undefined && args.currentSticker.description.length > 0) ? \nargs.currentSticker.description : ''",
    "sticker_description_option": "let regex_match = content.match(/\\[\\{sticker_description_option\\}(?<description>.{0,30})\\]/); (args.currentSticker.description !== null && args.currentSticker.description !== undefined && args.currentSticker.description.length > 0) ? content = content.replace(/\\[\\{sticker_description_option\\}.{0,30}\\]/, regex_match.groups.description) : content = content.replace(/\\[\\{sticker_description_option\\}.{0,30}\\]/, '')"
}